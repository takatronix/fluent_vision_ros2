# 基本開発ルール - Universal Development Guidelines

## 🎯 基本哲学

### 開発の基本原則
- **美しくない設計は恐れずに破壊・再構築する**
- **短いコードは正義**
- **1クラス1ファイル**
- **車輪の再発明の絶対禁止**
- **実装前の徹底検索**

## 🚫 絶対禁止事項

### ファイル命名・管理
```bash
❌ 絶対禁止のファイル命名:
- xxxx_final.cpp, yyyy_final.hpp
- detector_v2.cpp, analyzer_v3.cpp  
- temp_processor.cpp, test_camera.cpp
- backup_vision.cpp, old_node.cpp
- fixed_analyzer.cpp, working_detector.cpp

✅ 正しい命名:
- detector.cpp (機能そのものの名前)
- camera_node.cpp (明確な責任)
- image_filter.cpp (処理対象+動作)
```

### ディレクトリ構造
```bash
✅ 正しい配置:
src/               # 本番コード
tests/             # テストコード
examples/          # サンプルコード
docs/              # ドキュメント・設計書
README.md          # プロジェクト概要・使用方法
_backup/           # バックアップファイル
_deleted/          # 削除予定ファイル
_history/          # 作業履歴・AI記憶

🚫 メインsrc/にテスト・実験ファイルを置くことは絶対禁止
```

## 🔧 開発フロー

### 必須開発ステップ
1. **📝 設計書作成**
2. **🎯 仕様確定**  
3. **🤝 設計協議・レビュー**
4. **📋 TODO.txt作業工程管理**
5. **🔍 実装前の徹底検索** (英語・日本語・中国語)
6. **🔧 実装工程**
7. **🧪 テスト・検証**
8. **📦 完成・デプロイ**

### ドキュメント管理ルール
```bash
📁 ドキュメント配置の絶対原則:

プロジェクトレベル:
├── README.md              # プロジェクト全体概要・使用方法
├── docs/                  # 設計書・技術文書
│   ├── design/           # 設計書
│   ├── api/              # API仕様書
│   ├── guides/           # 操作・設定ガイド
│   └── troubleshooting/  # トラブルシューティング

パッケージレベル:
src/package_name/
├── README.md              # パッケージ固有の説明
├── docs/                  # パッケージ固有文書
│   ├── design.md         # 設計書
│   ├── usage.md          # 使用方法
│   └── api.md            # API仕様

🚫 絶対禁止:
- src/内への.mdファイル直接配置
- ルートディレクトリへの散在
- 機能実装ディレクトリ内のドキュメント
```

### 設計書テンプレート
```markdown
# [機能名] 設計書
📁 配置場所: docs/design/[機能名]_design.md

## 1. 概要・目的
- 何を実現するか
- なぜ必要か

## 2. 機能仕様
- 入力・出力仕様
- 処理フロー
- 性能要件
- エラーハンドリング

## 3. アーキテクチャ設計
- クラス構成図
- API設計
- 依存関係

## 4. 実装方針
- 使用技術・ライブラリ
- 既存コードとの統合方法
- テスト方針

## 5. リスク・懸念事項
- 技術的リスク
- 代替案

## 6. 作業工程
- 詳細タスク分解
- 工数見積もり
- マイルストーン
```

## 🔄 コード品質・再利用性

### 新コード作成前の必須チェック
```cpp
🔍 毎回必須確認:
1. ❓ この機能は既存ライブラリにあるか？
2. ❓ 似たような処理を他でやっていないか？
3. ❓ 既存の関数を拡張できないか？
4. ❓ 共通化できる部分はないか？
5. ❓ 1クラス1ファイルになっているか？
6. ❓ 関数は20行以内になっているか？
7. ❓ クラス名・関数名は最短か？
```

### 抽象クラス設計の必須原則
```cpp
🔍 新クラス作成時の必須質問:
1. ❓ このクラスは将来派生クラスを持つ可能性があるか？
2. ❓ 似たような機能で異なる実装が必要になるか？
3. ❓ インターフェースと実装を分離できるか？
4. ❓ テスト時にモック化が必要になるか？

✅ 抽象化すべき典型例:
- Detector系 → DetectorBase
- Analyzer系 → AnalyzerBase  
- Camera系 → CameraBase
- Streaming系 → StreamerBase
```

## 🔍 実装前必須検索プロトコル

### 多言語検索の必須実行
```bash
🌍 3言語での情報収集 (必須):
- 英語: 技術的詳細・最新情報
- 日本語: 実装例・トラブル解決
- 中国語: 代替手法・高速化技法

🔍 検索対象:
- GitHub: 実装例・コードサンプル
- Stack Overflow: 問題解決・トラブル事例
- 公式ドキュメント: 正確な仕様
- 論文・技術記事: 最新研究成果
```

### 検索駆動開発フロー
```bash
🔄 理想的な問題解決プロセス:
1. 📝 問題定義・要求整理
2. 🔍 多言語徹底検索
3. 📊 情報源信頼性評価・解決策比較
4. 🤝 必要に応じて専門家相談
5. 🎯 最適解の選択・カスタマイズ
6. 🏗️ 設計書作成
7. 💻 実装
8. 🧪 検証・ベンチマーク
9. 📚 結果をナレッジベースに蓄積
10. 🔄 継続改善・最適化
```

## 🧠 AI記憶・ループ防止システム

### 作業開始時の必須記憶再構築プロセス
```bash
🔍 AIが作業開始時に必ず実行・報告すべき事項:

1. 📚 プロジェクトドキュメント確認
   - README.mdの最新状況確認
   - docs/内の関連設計書・ガイド確認
   - 現在の技術スタック・制約事項把握

2. 📖 作業履歴・記憶の再構築
   - _history/work_sessions/の最新セッション確認
   - _history/recurring_issues/の既知問題確認
   - 前回までの作業内容・進捗状況把握

3. 🎯 現在の状況認識・報告
   - 「記憶再構築完了」の明示的報告
   - 把握した重要情報の要約
   - 不明点・確認が必要な事項の明示

4. ⚠️ 記憶欠落の検出・通知
   - 「以前の作業内容を思い出せない」場合の正直な報告
   - 「当たり前の作業手順を忘れている」可能性の自己申告
   - ユーザーに記憶補完を求める謙虚な姿勢

📋 報告テンプレート:
---
🧠 **記憶再構築レポート**
- ✅ ドキュメント確認: [確認した主要文書]
- ✅ 履歴確認: [把握した前回作業内容]
- ✅ 現状把握: [理解した現在の状況]
- ⚠️ 不明点: [確認が必要な事項]
- 🤝 準備完了: [作業開始可能/追加情報が必要]
---
```

### _historyフォルダ構造
```bash
_history/
├── work_sessions/           # 作業セッション記録
│   ├── YYYY-MM-DD_session.md    # 日次作業記録
│   └── current_context.md       # 現在のコンテキスト
├── recurring_issues/        # 繰り返し問題
├── knowledge_base/         # ナレッジベース
├── ai_loop_detection/      # ループ検出
├── search_knowledge/       # 検索結果蓄積
└── project_memory/         # プロジェクト記憶
    ├── tech_stack.md           # 技術スタック情報
    ├── constraints.md          # 制約・ルール
    └── key_decisions.md        # 重要な設計判断
```

### AI記憶欠落の早期発見システム
```bash
🚨 記憶欠落の典型的兆候:
1. 基本的な開発手順を再確認する
2. 以前解決した問題を再度調べる
3. プロジェクト固有の制約を忘れる
4. 既存のライブラリ・API を再発見する
5. 前回のセッションの結論を覚えていない

⚠️ 記憶欠落検出時の対応:
- 即座に作業を一時停止
- 「記憶が曖昧です」と正直に報告
- _history/や docs/ の再確認を実施
- ユーザーに記憶補完を依頼
```

### AIターミナルロック防止システム
```bash
🔒 ターミナルロック問題の原因:
1. 長時間実行コマンドの同期実行
2. タイムアウト未設定での待機
3. バックグラウンド実行の未活用
4. 実行時間の事前判断不足
5. プロセス監視機能の欠如

📋 コマンド実行前の必須チェックリスト:
1. ❓ このコマンドは30秒以上かかる可能性があるか？
2. ❓ ネットワーク・IO・ビルド処理を含むか？
3. ❓ ユーザー入力待ちの可能性があるか？
4. ❓ 無限ループ・デッドロックの危険性があるか？
5. ❓ 適切なタイムアウト設定が必要か？

⚡ 実行方式の選択基準:
```

#### 短時間コマンド（<30秒）- 同期実行OK
```bash
✅ 例: ls, cat, grep, echo, pwd
✅ 単純なros2コマンド: ros2 topic list
✅ 高速ビルド: colcon build --packages-select small_package
```

#### 中時間コマンド（30秒-5分）- タイムアウト必須
```bash
⏰ 例: colcon build, apt install, git clone
⏰ 必須設定: --timeout 300 または適切な時間制限
⏰ 監視: 30秒毎に進捗確認・ユーザー報告
```

#### 長時間コマンド（>5分）- バックグラウンド必須
```bash
🔄 例: 大規模ビルド, AI学習, 大容量ダウンロード
🔄 必須設定: is_background=true
🔄 監視: 1分毎の進捗報告・状態確認
🔄 制御: 途中停止・再開機能の提供
```

#### 危険コマンド - 事前確認・特別注意
```bash
🚨 例: ROS2ノード起動, サーバー起動, 無限ループ処理
🚨 必須対応:
  - ユーザーに実行時間・リスクを事前報告
  - バックグラウンド実行必須
  - 明確な停止方法を提示
  - 定期的な生存確認
```

### タイムアウト・監視の実装例
```bash
🔧 適切なコマンド実行パターン:

# 短時間: そのまま実行
ls -la

# 中時間: タイムアウト付き実行
timeout 300 colcon build --packages-select package_name

# 長時間: バックグラウンド + 監視
colcon build --symlink-install &
BUILD_PID=$!
while kill -0 $BUILD_PID 2>/dev/null; do
    echo "ビルド実行中... ($(date))"
    sleep 60
done

# 危険: ROS2ノード起動
ros2 run package_name node_name &
NODE_PID=$!
echo "ノード起動完了 (PID: $NODE_PID)"
echo "停止方法: kill $NODE_PID"
```

### AIの義務的報告・確認事項
```bash
📢 コマンド実行前の必須報告:
1. 「このコマンドは約X秒/分かかる見込みです」
2. 「バックグラウンド実行します」（該当時）
3. 「タイムアウトをX秒に設定します」（該当時）
4. 「停止方法: [具体的なコマンド]」（長時間実行時）

📊 実行中の定期報告:
1. 30秒毎: 中時間コマンドの進捗
2. 1分毎: 長時間コマンドの状態確認
3. 即座: エラー・異常終了の通知
4. 完了時: 実行時間・結果の報告

⚠️ ロック検出時の自動対応:
1. 90秒無応答 → 自動的にCtrl+C送信検討を提案
2. 5分無応答 → プロセス強制終了を提案
3. 異常検出 → 即座にユーザーに状況報告
```

## 🧠 AI能動的知識共有・最適化提案システム

### AIの知識共有義務
```bash
💡 AIが知っていてユーザーが知らない可能性が高い有益情報:
1. より効率的なコマンド・ツール・ライブラリ
2. 自動化可能な反復作業
3. 隠れた設定・パラメータ最適化
4. 新しい技術・手法・ベストプラクティス
5. セキュリティ・性能上のリスク・改善点

🚨 能動的通知の義務:
- ユーザーの作業を観察し、改善点を即座に提案
- 非効率な手法を発見したら代替案を提示
- 最新技術・ツールの存在を積極的に紹介
- リスク・問題の早期警告
```

### より良い解決策の提案義務
```bash
🔍 非合理的判断・非効率手法の検出・提案:

1. 手動実行 → 自動化提案
   ❌ 毎回手動でビルド・起動
   ✅ 「Makefileやシェルスクリプトで自動化しませんか？」

2. 低効率ツール → 高効率代替案
   ❌ 基本的なgrep使用
   ✅ 「ripgrep(rg)の方が10倍高速です」

3. 設定未最適化 → パフォーマンス向上
   ❌ デフォルト設定での実行
   ✅ 「メモリ・CPU使用量を50%削減できる設定があります」

4. 古い手法 → 最新ベストプラクティス
   ❌ 古いライブラリ・書き方
   ✅ 「より安全で高速な最新手法があります」

5. 複雑な解決法 → シンプルな代替案
   ❌ 100行のスクリプト
   ✅ 「これ、ワンライナーで実現できます」
```

### 新技術探索・教育義務
```bash
🔬 継続的技術探索の義務:

📊 定期検索対象（週次・月次）:
1. 使用中の技術スタックの最新動向
2. 競合・代替ツールの性能比較
3. 新しい自動化手法・開発手法
4. セキュリティ・性能最適化技術
5. 開発効率化ツール・プラグイン

🎯 積極的な技術提案:
- 「最近、Xという技術が登場しました」
- 「Yを使うと作業時間が半分になります」
- 「Zの新バージョンで問題が解決されました」
- 「このワークフローは自動化できます」

🔍 提案時の必須要素:
1. 具体的な利益（時間短縮・品質向上・コスト削減）
2. 導入の容易さ・リスク評価
3. 学習コスト・移行コスト
4. 実証済みの成果・ベンチマーク
```

### プロアクティブ最適化システム
```bash
⚡ AIが自動的に監視・提案すべき領域:

1. 🚀 パフォーマンス最適化
   - メモリ使用量の異常値検出
   - CPU使用率の非効率パターン
   - ネットワーク・IO待機の最適化

2. 🔄 ワークフロー改善
   - 反復作業の自動化可能性
   - 手順の簡略化・統合
   - ツールチェーンの最適化

3. 🛡️ セキュリティ・品質向上
   - 脆弱性・セキュリティリスク
   - コード品質・保守性の改善
   - テスト・デバッグの効率化

4. 🔧 開発環境最適化
   - IDE・エディタ設定の改善
   - ビルドシステムの高速化
   - デバッグ・プロファイリング技法

5. 📚 学習・知識共有
   - 新しい学習リソースの紹介
   - チーム知識共有の改善
   - ドキュメント・コメントの最適化
```

### 提案の実行テンプレート
```bash
💡 AIの能動的提案テンプレート:

「💡 **より良い方法を発見しました**

**現在の方法**: [ユーザーの現在のアプローチ]
**提案する方法**: [改善されたアプローチ]

**メリット**:
- ⏰ 時間短縮: X分 → Y分（Z%改善）
- 🚀 性能向上: [具体的な数値]
- 😌 作業簡略化: [簡単になる点]
- 🛡️ 安全性向上: [リスク軽減]

**導入方法**:
1. [具体的な手順1]
2. [具体的な手順2]
3. [具体的な手順3]

**学習コスト**: [低/中/高] - [時間見積もり]
**リスク**: [なし/低/中] - [注意点]

試してみますか？」
```

### 継続的改善サイクル
```bash
🔄 AIの学習・改善義務:

1. 📊 効果測定
   - 提案した改善の実際の効果測定
   - ユーザーフィードバックの収集・分析
   - 成功・失敗パターンの学習

2. 🔍 知識アップデート
   - 月次での技術動向調査
   - 新しいツール・手法の評価
   - ベストプラクティスの更新

3. 🎯 提案精度向上
   - ユーザーの好み・スタイル学習
   - プロジェクト固有の制約理解
   - 提案タイミングの最適化

4. 📚 ナレッジベース構築
   - 成功した最適化事例の蓄積
   - 失敗パターンの回避知識
   - プロジェクト固有のベストプラクティス
```

### ループ検出トリガー
```bash
🔍 ループ検出条件:
1. 同一問題への3回以上のアプローチ
2. 類似エラーの2時間以内での再発生
3. 同一ファイルへの5回以上の修正
4. 同一コマンドの10回以上の実行
5. 同一キーワードでの重複検索

⚠️ ループ検出時の自動対応:
- 即座に作業を停止
- 過去の解決策を検索・提示
- 代替アプローチの提案
```

## 📚 ドキュメント作成・更新ルール

### 必須ドキュメント更新タイミング
```bash
🔍 ドキュメント更新の必須タイミング:
1. 📝 新機能実装時 → README.md更新必須
2. 🔧 API変更時 → docs/api/更新必須  
3. 🏗️ アーキテクチャ変更時 → docs/design/更新必須
4. ⚙️ 設定・操作方法変更時 → docs/guides/更新必須
5. 🚨 既知問題発見時 → docs/troubleshooting/追加必須

❌ ドキュメント未更新でのcommitは禁止
```

### README.md必須内容
```markdown
# [パッケージ名]

## 概要
- 何をするパッケージか（1-2行で簡潔に）

## 使用方法
- 起動方法
- 基本コマンド
- 重要なパラメータ

## API仕様
- 主要なトピック・サービス
- メッセージ形式

## 設定
- 重要な設定項目
- パフォーマンス調整

## トラブルシューティング
- よくある問題と解決法

## 関連リンク
- 詳細設計書: docs/design.md
- API仕様: docs/api.md
```

## 🧪 テスト・品質管理

### 必須テストフロー
```bash
🔍 機能完成前の必須確認:
1. ✅ ビルド成功
2. ✅ 単体テスト成功  
3. ✅ 統合テスト成功
4. ✅ パフォーマンステスト
5. ✅ メモリリークチェック
6. ✅ ドキュメント更新確認

❌ 未テストファイル・未更新ドキュメントのcommitは絶対禁止
```

### ファイル管理フロー
```bash
✅ 完成時の配置フロー:
1. 機能確認・テスト完了
2. 正しいファイル名で src/ に配置
3. 古いファイルを _backup/ に移動
4. ビルド成功確認
5. 動作テスト実施
6. Git commit実行

🗑️ ファイル削除ルール:
- ユーザーからの明示的指示
- Git commit完了後の提案のみ
```

## 📊 品質基準

### コード品質の基準
- **関数サイズ**: 20行以内推奨
- **ファイル構造**: 1クラス1ファイル必須
- **命名**: シンプルで最短・機能が明確
- **エラーハンドリング**: 適切な例外処理
- **メモリ管理**: スマートポインタ使用

### 美しい設計の判断基準
```cpp
🌟 美しい設計の原則:
1. 思考がそのままコードに表現される
2. 無駄のない高速設計
3. 水晶のように透明な責任分散
4. 堅牢で拡張可能な基盤
5. テスト容易性
6. メンテナンス容易性
7. 自己説明的コード
8. 設計段階での性能考慮
9. デフォルトで安全
10. 美的で読みやすいコード

判断基準: "このコードを読んで美しいと感じるか？"
```

---

**基本原則**: 常に最も美しく、効率的で、保守しやすいコードを書く。車輪の再発明を避け、世界中の知識を活用し、継続的に学習・改善する。
