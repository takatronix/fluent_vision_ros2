# アスパラガス分析ノード設計書

**作成日時**: 2025年8月8日 07:58  
**種別**: plan  
**機能名**: アスパラ分析設計

## 概要
統合されたアスパラガス分析ノード（`fv_aspara_analyzer_node`）の設計書。1つのノードで設定ファイルにより動作を切り替え、D415/D405両カメラに対応する。

## 基本設計方針

### 1. 統合アーキテクチャ
- **1つのノード**: `fv_aspara_analyzer_node`
- **設定ファイル分岐**: `fv_aspara_analyzer_d415.yaml` / `fv_aspara_analyzer_d405.yaml`
- **ハードコーディング禁止**: すべてのトピック名・パラメータは設定ファイルから読み込み

### 2. 内蔵ポイントクラウド生成
- **外部ノード依存なし**: 深度画像から内部で点群生成
- **動的キャリブレーション**: カメラInfoトピックから内部パラメータを動的取得

## 機能要件

### 入力データ（設定ファイルで指定）
1. **`detection_topic`**: YOLO物体検出結果（`vision_msgs::msg::Detection2DArray`）
2. **`camera_topic`**: カラー画像（`sensor_msgs::msg::Image`）
3. **`depth_topic`**: 深度画像（`sensor_msgs::msg::Image`）
4. **`camera_info_topic`**: カラーカメラキャリブレーション（`sensor_msgs::msg::CameraInfo`）
5. **`depth_camera_info_topic`**: 深度カメラキャリブレーション（`sensor_msgs::msg::CameraInfo`）
6. **`mask_topic`**: セグメンテーションマスク（`sensor_msgs::msg::Image`）

### 処理機能
1. **ポイントクラウド生成**
   - 深度画像 + カラー画像 → 3D点群データ
   - 深度カメラパラメータによる3D座標変換
   - カラー情報の付与

2. **非同期物体検出処理**
   - 物体検出結果は遅延して非同期で受信
   - 独自ID管理システムによるオブジェクト追跡
   - 同じクラスIDでn%以上重複で同一オブジェクト判定

3. **物体クラス管理**
   - **クラスID 0**: アスパラガス本体（緑の矩形）
     - 選択中: 80%透過度で太め表示
     - 非選択: 40%透過度で色も落とす
   - **クラスID 1**: アスパラの穂（追加情報）
     - 単一アスパラ内の穂: そのアスパラの追加情報として使用
     - 複数アスパラ重複時の穂: 関連付けしない

4. **選択中アスパラ管理**
   - 起動時: selected_asparagus_id = -1（選択なし）
   - 選択中IDがある場合: そのIDを継続追跡
   - 画面から外れた場合: 最適候補を新たに選択
   - 最適候補選定: 距離が短い（矩形が大きい）かつconfidenceが高いもの

5. **アスパラガス領域抽出**
   - バウンディングボックス内点群抽出
   - 選択中アスパラガスの優先処理
   - アスパラの穂情報の統合

6. **アスパラ選択サービス**
   - **次のアスパラサービス**: `next` - 循環して次のアスパラを選択
   - **前のアスパラサービス**: `prev` - 循環して前のアスパラを選択
   - 末尾→先頭、先頭→末尾への循環選択

7. **スムースアニメーション表示**
   - 同じIDのアスパラ矩形をスムースに補間表示
   - 矩形位置・サイズの線形補間
   - フレーム間の滑らかな遷移で見やすく表示

8. **画面情報表示**
   - **左上表示**:
     - 検出しているオブジェクトの個数
     - カメラのFPS（フレームレート）
     - 認識のFPS（物体検出処理レート）
   - リアルタイムパフォーマンス監視

9. **表示モード制御**
   - **アスパラガス未検出時**: カメラ映像をそのまま表示
   - **アスパラガス検出時**: 
     - アスパラガス矩形以外を80%暗くする
     - アスパラガスだけを際立たせる表示
     - "ふわー"っとした暗化エフェクト

10. **品質分析**
   - **長さ測定**: PCA + スケルトン抽出の複合手法
   - **曲がり度測定**: 直線フィッティング残差 + 曲率ベース
   - **太さ測定**: 断面解析による平均直径算出
   - **グレード判定**: 長さ・曲がり度・太さの複合評価
   - **切断対象判定**: 23cm以上で切断対象として表示
   - **品質表示**: 長さ・曲がり度・太さ・グレードを常時表示

4. **点群フィルタリング（fluent_cloudライブラリ活用）**
   - **基本フィルタ**:
     - `filterByDistance(min, max)` - 距離範囲フィルタ
     - `filterByHeight(min_z, max_z)` - 高さ範囲フィルタ
     - `voxelGridFilter(leaf_size)` - ダウンサンプリング
   - **ノイズ除去**:
     - `statisticalOutlierRemoval()` - 統計的外れ値除去
     - `radiusOutlierRemoval()` - 半径ベース外れ値除去
   - **高度なフィルタ**:
     - `adaptiveDistanceFilter()` - 適応的距離フィルタ
     - `smoothMLS()` - Moving Least Squares平滑化
     - `conditionalRemoval()` - 条件付き除去
   - **アスパラガス専用**:
     - `filterHarvestable(min_length, max_length)` - 収穫可能サイズフィルタ

### 出力データ（設定ファイルで指定）
1. **`pointcloud_topic`**: 生成された生点群（他ノードが使用）
2. **`output_filtered_pointcloud_topic`**: フィルタリング済み点群
3. **`output_annotated_image_topic`**: 注釈付き可視化画像

## 設定パラメータ

### トピック設定
```yaml
# 入力トピック
detection_topic: "/fv/d415/object_detection/detections"
camera_topic: "/fv/d415/color/image_raw"
depth_topic: "/fv/d415/depth/image_rect_raw"
camera_info_topic: "/fv/d415/color/camera_info"
depth_camera_info_topic: "/fv/d415/depth/camera_info"
mask_topic: "/fv/d415/segmentation_mask/image"
imu_topic: "/livox/imu"

# 出力トピック
pointcloud_topic: "/fv/d415/asparagus/points"
output_filtered_pointcloud_topic: "/fv/d415/aspara_analysis/asparagus/points"
output_annotated_image_topic: "/fv/d415/aspara_analysis/result"
```

### 処理パラメータ
```yaml
# 基本設定
min_confidence: 0.3
pointcloud_distance_min: 0.1
pointcloud_distance_max: 2.0
aspara_filter_distance: 0.05

# ノイズ除去
noise_reduction_neighbors: 50
noise_reduction_std_dev: 1.0
voxel_leaf_size: 0.010

# 品質評価
harvest_min_length: 0.23               # 切断対象の最小長さ（23cm）
harvest_max_length: 0.50               # 最大長さ（50cm）
straightness_threshold: 0.7             # 真っ直ぐ度閾値（70%以上で収穫可能）
cutting_target_length: 0.23            # 切断対象判定長さ（23cm以上）

# 曲がり度評価
max_curvature_deviation: 0.05          # 最大曲がり許容値（5cm）
curvature_segments: 10                  # 曲率計算セグメント数

# 太さ評価
min_diameter: 0.008                     # 最小直径（8mm）
max_diameter: 0.025                     # 最大直径（25mm）
diameter_measurement_points: 5          # 直径測定ポイント数

# グレード判定基準
grade_a_min_length: 0.25               # グレードA最小長さ（25cm）
grade_a_max_curvature: 0.02            # グレードA最大曲がり（2cm）
grade_a_min_diameter: 0.012            # グレードA最小直径（12mm）
grade_b_min_length: 0.23               # グレードB最小長さ（23cm）
grade_b_max_curvature: 0.05            # グレードB最大曲がり（5cm）
grade_b_min_diameter: 0.010            # グレードB最小直径（10mm）

# 表示設定
show_quality_info: true                 # 品質情報表示有効
show_length_always: true                # 長さを常に表示
show_curvature: true                    # 曲がり度表示
show_diameter: true                     # 太さ表示
show_grade: true                        # グレード表示

# 表示色設定
grade_a_color: [0, 255, 0]             # グレードA色（緑）BGR
grade_b_color: [0, 255, 255]           # グレードB色（黄）BGR
grade_c_color: [0, 128, 255]           # グレードC色（オレンジ）BGR
cutting_target_color: [0, 255, 0]      # 切断対象の色（緑）BGR
normal_asparagus_color: [128, 128, 128] # 通常アスパラガスの色（グレー）BGR

# テキスト表示設定
quality_text_size: 0.5                 # 品質テキストのサイズ
quality_text_line_spacing: 15          # テキスト行間隔
quality_text_position_offset: 10       # テキスト位置オフセット

# 日本語ラベル設定
label_length: "長さ"                    # 長さラベル
label_curvature: "曲がり"               # 曲がり度ラベル  
label_diameter: "太さ"                  # 太さラベル
label_grade: "グレード"                 # グレードラベル
label_cutting_target: "切断対象"        # 切断対象ラベル

# グレード表示文字
grade_a_text: "A級"                     # グレードAテキスト
grade_b_text: "B級"                     # グレードBテキスト
grade_c_text: "C級"                     # グレードCテキスト
grade_ng_text: "規格外"                 # グレードNG（規格外）テキスト

# 単位表示
unit_length: "cm"                       # 長さ単位
unit_curvature: "cm"                    # 曲がり度単位
unit_diameter: "mm"                     # 太さ単位

# 表示モード設定
enable_highlight_mode: true             # ハイライトモード有効
background_dimming_alpha: 0.2           # 背景暗化透明度（80%暗くする = 0.2）
dimming_transition_speed: 0.15          # 暗化遷移スピード（0.0-1.0）
highlight_blur_kernel_size: 15          # ぼかしカーネルサイズ（奇数）
enable_smooth_dimming: true             # スムーズ暗化有効

# オブジェクト追跡設定
object_tracking_overlap_threshold: 0.7     # 重複度閾値（70%以上で同一オブジェクト）
object_tracking_timeout_ms: 5000          # オブジェクト追跡タイムアウト（5秒）

# 表示設定
selected_asparagus_opacity: 0.8           # 選択中: 80%透過度
selected_asparagus_thickness: 3           # 選択中の矩形線の太さ
unselected_asparagus_opacity: 0.4         # 非選択: 40%透過度
unselected_asparagus_thickness: 1         # 非選択の矩形線の太さ

# アニメーション設定
smooth_animation_enabled: true             # スムースアニメーション有効
animation_interpolation_alpha: 0.3         # 線形補間係数（0.0-1.0）
animation_min_movement_threshold: 2.0      # アニメーション開始の最小移動距離（ピクセル）
```

## クラス設計

### メインクラス: `FvAsparaAnalyzerNode`
```cpp
class FvAsparaAnalyzerNode : public rclcpp::Node {
private:
    // サブスクライバー
    rclcpp::Subscription<vision_msgs::msg::Detection2DArray>::SharedPtr detection_sub_;
    rclcpp::Subscription<sensor_msgs::msg::Image>::SharedPtr camera_sub_;
    rclcpp::Subscription<sensor_msgs::msg::Image>::SharedPtr depth_sub_;
    rclcpp::Subscription<sensor_msgs::msg::CameraInfo>::SharedPtr camera_info_sub_;
    rclcpp::Subscription<sensor_msgs::msg::CameraInfo>::SharedPtr depth_camera_info_sub_;
    rclcpp::Subscription<sensor_msgs::msg::Image>::SharedPtr mask_sub_;
    
    // パブリッシャー
    rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr pointcloud_pub_;
    rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr filtered_pointcloud_pub_;
    rclcpp::Publisher<sensor_msgs::msg::Image>::SharedPtr annotated_image_pub_;
    
    // サービス
    rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr next_asparagus_service_;
    rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr prev_asparagus_service_;
    
    // データ保持
    sensor_msgs::msg::Image::SharedPtr latest_camera_image_;
    sensor_msgs::msg::Image::SharedPtr latest_depth_image_;
    sensor_msgs::msg::CameraInfo::SharedPtr camera_info_;
    sensor_msgs::msg::CameraInfo::SharedPtr depth_camera_info_;
    
    // 処理パラメータ
    double min_confidence_;
    double pointcloud_distance_min_;
    double pointcloud_distance_max_;
    // ... 他のパラメータ
    
    // FPS管理（vision_aiの既存FPSCounterユーティリティを使用）
    struct FPSCounter {
        int count = 0;
        std::chrono::steady_clock::time_point last_reset = std::chrono::steady_clock::now();
        double current_fps = 0.0;
        
        void tick();
        double getFPS() const;
    };
    
    FPSCounter camera_fps_counter_;
    FPSCounter detection_fps_counter_;
    
public:
    FvAsparaAnalyzerNode();
    ~FvAsparaAnalyzerNode();
    
private:
    // コールバック関数
    void detectionCallback(const vision_msgs::msg::Detection2DArray::SharedPtr msg);
    void cameraCallback(const sensor_msgs::msg::Image::SharedPtr msg);
    void depthCallback(const sensor_msgs::msg::Image::SharedPtr msg);
    void cameraInfoCallback(const sensor_msgs::msg::CameraInfo::SharedPtr msg);
    void depthCameraInfoCallback(const sensor_msgs::msg::CameraInfo::SharedPtr msg);
    void maskCallback(const sensor_msgs::msg::Image::SharedPtr msg);
    
    // 処理関数
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr generatePointCloud();
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr extractAsparagusBbox(
        const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud,
        const vision_msgs::msg::Detection2D& detection);
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr filterPointCloud(
        const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud);
    
    // 分析関数
    double calculateAsparaLength(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud);
    double calculateStraightness(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud);
    bool isHarvestable(double length, double straightness);
    
    // ユーティリティ
    void loadParameters();
    cv::Mat createAnnotatedImage(const cv::Mat& original, 
                                const std::vector<vision_msgs::msg::Detection2D>& detections);
};
```

## データフロー

```
1. カメラ画像 → camera_callback → latest_camera_image_保存
2. 深度画像 → depth_callback → latest_depth_image_保存
3. カメラInfo → camera_info_callback → camera_info_保存
4. 深度カメラInfo → depth_camera_info_callback → depth_camera_info_保存
5. 物体検出結果 → detection_callback → メイン処理開始
   ↓
6. generatePointCloud() → 点群生成 → pointcloud_topic公開
   ↓
7. extractAsparagusBbox() → アスパラ領域抽出
   ↓
8. filterPointCloud() → ノイズ除去・フィルタリング
   ↓
9. 品質分析 → 長さ・真っ直ぐ度計算
   ↓
10. createAnnotatedImage() → 注釈付き画像作成
    ↓
11. 結果公開 → filtered_pointcloud_topic + annotated_image_topic
```

## 実装上の注意点

### 1. 同期処理
- 複数のセンサーデータを同期して処理
- タイムスタンプベースの同期機構

### 2. エラーハンドリング
- カメラInfoが未受信時の処理
- 画像データ不整合時の処理
- 点群生成失敗時の処理

### 3. パフォーマンス
- 点群処理の最適化
- メモリ効率的な処理
- フレームレート維持

### 4. 拡張性
- 新しいカメラ型番への対応
- 新しい品質評価指標の追加
- 複数アスパラガス同時検出への対応

## テスト計画

### 1. 単体テスト
- 点群生成機能のテスト
- 品質分析アルゴリズムのテスト
- フィルタリング機能のテスト

### 2. 統合テスト
- D415/D405両カメラでの動作確認
- 実際のアスパラガス検出・分析テスト
- 長時間稼働テスト

### 3. 性能テスト
- フレームレート測定
- メモリ使用量測定
- CPU使用率測定

## 点群サイドパネル表示機能

### 11. **選択中アスパラの3D点群表示**
   - **表示位置**: 選択中アスパラの矩形左側に同サイズのパネル
   - **表示内容**: フィルタリング済みアスパラガス点群の3Dビュー
   - **視点設定**: 真横からの視点（Y軸方向から見た形）
   - **回転機能**: 点群をリアルタイムで回転表示
   - **背景**: 黒色80%透過の矩形背景
   - **品質情報**: 矩形右側にテキスト、左側に点群表示のレイアウト

### 点群パネル設定パラメータ
```yaml
# 点群サイドパネル設定
pointcloud_panel:
  enabled: true                           # 点群パネル表示有効
  background_color: [0, 0, 0]            # パネル背景色（黒）BGR
  background_alpha: 0.2                   # パネル背景透明度（80%透過）
  
  # 3D表示設定
  initial_view_angle: 90.0                # 初期視点角度（度、真横=90°）
  rotation_speed: 1.0                     # 回転速度（度/フレーム）
  auto_rotate: true                       # 自動回転有効
  rotation_axis: "z"                      # 回転軸（"x", "y", "z"）
  
  # 点群描画設定
  point_size: 2                           # 点のサイズ（ピクセル）
  point_color_mode: "rgb"                 # 点の色モード（"rgb", "depth", "height"）
  depth_color_min: [0, 0, 255]          # 深度色最小値（近い=青）BGR
  depth_color_max: [255, 0, 0]           # 深度色最大値（遠い=赤）BGR
  
  # パネルサイズ設定
  panel_size_ratio: 1.0                   # 矩形に対するパネルサイズ比（1.0=同サイズ）
  panel_margin: 10                        # パネルと矩形の間隔（ピクセル）
  
  # 座標系設定
  coordinate_display: true                # 座標軸表示有効
  coordinate_size: 0.05                   # 座標軸サイズ（メートル）
  grid_display: true                      # グリッド表示有効
  grid_size: 0.01                        # グリッド間隔（メートル）
```

### 実装詳細

#### 1. **3D→2D投影処理**
```cpp
// 3D点群を2Dパネルに投影する関数
cv::Mat renderPointCloudToPanel(
    const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud,
    const cv::Size& panel_size,
    double rotation_angle) {
    
    // 回転行列の生成
    Eigen::Matrix3f rotation_matrix = createRotationMatrix(rotation_angle);
    
    // 点群の回転
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr rotated_cloud(new pcl::PointCloud<pcl::PointXYZRGB>);
    pcl::transformPointCloud(*cloud, *rotated_cloud, rotation_matrix);
    
    // 2D投影（X-Z平面への投影、Y軸方向から見た形）
    cv::Mat panel = cv::Mat::zeros(panel_size, CV_8UC3);
    projectPointsToImage(rotated_cloud, panel, panel_size);
    
    return panel;
}
```

#### 2. **レイアウト統合処理**
```cpp
// アスパラガス情報の統合レイアウト描画
void drawAsparagusBoundingBoxWithPanel(
    cv::Mat& image,
    const vision_msgs::msg::Detection2D& detection,
    const AsparagusMeasurement& measurement,
    const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& asparagus_cloud) {
    
    // 基本矩形の描画
    cv::Rect bbox = getBoundingRect(detection);
    
    // 左側：点群パネル
    cv::Rect panel_rect(bbox.x - bbox.width - panel_margin, bbox.y, bbox.width, bbox.height);
    cv::Mat panel = renderPointCloudToPanel(asparagus_cloud, panel_rect.size(), current_rotation_angle);
    
    // パネル背景（80%透過黒）
    cv::Mat background = cv::Mat::zeros(panel_rect.size(), CV_8UC3);
    cv::addWeighted(image(panel_rect), 0.8, background, 0.2, 0, image(panel_rect));
    
    // 点群描画をオーバーレイ
    cv::addWeighted(image(panel_rect), 0.7, panel, 0.3, 0, image(panel_rect));
    
    // 右側：品質情報テキスト
    drawQualityText(image, bbox, measurement);
    
    // 回転角度更新（自動回転の場合）
    if (auto_rotate_enabled) {
        current_rotation_angle += rotation_speed;
        if (current_rotation_angle >= 360.0) current_rotation_angle -= 360.0;
    }
}
```

#### 3. **点群フィルタリング統合**
- 選択中アスパラガスの点群のみを抽出
- ノイズ除去とスムージング適用
- 表示用に適度にダウンサンプリング
- 座標軸とグリッドの描画

#### 4. **点群合成による高品質分析**
- **複数フレーム合成**: 時系列点群データを統合して高密度点群生成
- **真横視点最適化**: Y軸方向からの完全な側面ビューで分析
- **ノイズ除去強化**: 合成データによるノイズ除去と平滑化
- **アスパラガス完全形状復元**: 欠損部分の補完と形状最適化

```cpp
// 高品質点群合成クラス
class AsparagusMeshBuilder {
private:
    std::deque<pcl::PointCloud<pcl::PointXYZRGB>::Ptr> frame_history_;
    static constexpr int MAX_HISTORY_FRAMES = 30;  // 1秒分（30FPS想定）
    
public:
    // 複数フレームから高品質点群を合成
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr buildHighQualityMesh(
        const std::vector<pcl::PointCloud<pcl::PointXYZRGB>::Ptr>& frame_clouds) {
        
        // 1. 点群レジストレーション（位置合わせ）
        pcl::PointCloud<pcl::PointXYZRGB>::Ptr merged_cloud = registerAndMergeFrames(frame_clouds);
        
        // 2. 統計的外れ値除去（強化版）
        pcl::PointCloud<pcl::PointXYZRGB>::Ptr filtered_cloud = advancedNoiseRemoval(merged_cloud);
        
        // 3. Moving Least Squares平滑化
        pcl::PointCloud<pcl::PointXYZRGB>::Ptr smoothed_cloud = mlsSmoothing(filtered_cloud);
        
        // 4. アスパラガス軸に沿った正規化
        pcl::PointCloud<pcl::PointXYZRGB>::Ptr normalized_cloud = normalizeToAsparagusStem(smoothed_cloud);
        
        return normalized_cloud;
    }
    
private:
    // PCAベースの軸正規化
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr normalizeToAsparagusStem(
        const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud) {
        
        // PCA分析でアスパラガスの主軸を検出
        Eigen::Matrix3f eigenvectors;
        Eigen::Vector3f eigenvalues;
        computePCA(cloud, eigenvectors, eigenvalues);
        
        // 主軸をZ軸に、側面をX軸に回転変換
        Eigen::Matrix4f transform = createStemAlignmentTransform(eigenvectors);
        
        pcl::PointCloud<pcl::PointXYZRGB>::Ptr aligned_cloud(new pcl::PointCloud<pcl::PointXYZRGB>);
        pcl::transformPointCloud(*cloud, *aligned_cloud, transform);
        
        return aligned_cloud;
    }
};
```

#### 5. **完全認識時のTF作成とマッピング**
- **根元TF生成**: アスパラガス根元の3D座標と姿勢をTFとして作成
- **rtabmap統合**: 認識したアスパラガスの位置情報をSLAMマップに保存
- **座標系管理**: カメラ座標系からマップ座標系への変換

```cpp
// アスパラガスTF管理クラス  
class AsparagusTFManager {
private:
    tf2_ros::TransformBroadcaster tf_broadcaster_;
    tf2_ros::Buffer tf_buffer_;
    tf2_ros::TransformListener tf_listener_;
    
    // rtabmapサービスクライアント
    rclcpp::Client<rtabmap_ros::srv::AddLabel>::SharedPtr rtabmap_add_label_client_;
    rclcpp::Client<rtabmap_ros::srv::SetLabel>::SharedPtr rtabmap_set_label_client_;
    
public:
    AsparagusTFManager(rclcpp::Node::SharedPtr node) 
        : tf_broadcaster_(node)
        , tf_listener_(tf_buffer_)
        , node_(node) {
        
        // rtabmapサービスクライアント初期化
        rtabmap_add_label_client_ = node->create_client<rtabmap_ros::srv::AddLabel>("/rtabmap/add_label");
        rtabmap_set_label_client_ = node->create_client<rtabmap_ros::srv::SetLabel>("/rtabmap/set_label");
    }
    
    // 完全認識したアスパラガスのTF作成・保存
    bool registerAsparagusPose(int asparagus_id, 
                              const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& asparagus_cloud,
                              const AsparagusMeasurement& measurement) {
        
        // 1. 根元位置の計算
        Eigen::Vector3f stem_base_position = calculateStemBasePosition(asparagus_cloud);
        
        // 2. アスパラガス軸方向の計算  
        Eigen::Vector3f stem_direction = calculateStemDirection(asparagus_cloud);
        
        // 3. TF作成
        geometry_msgs::msg::TransformStamped asparagus_tf;
        asparagus_tf.header.stamp = node_->now();
        asparagus_tf.header.frame_id = "map";  // マップ座標系
        asparagus_tf.child_frame_id = "asparagus_" + std::to_string(asparagus_id);
        
        // 位置設定（根元）
        asparagus_tf.transform.translation.x = stem_base_position.x();
        asparagus_tf.transform.translation.y = stem_base_position.y(); 
        asparagus_tf.transform.translation.z = stem_base_position.z();
        
        // 姿勢設定（茎の向き）
        Eigen::Quaternionf quat = calculateOrientationFromDirection(stem_direction);
        asparagus_tf.transform.rotation.x = quat.x();
        asparagus_tf.transform.rotation.y = quat.y();
        asparagus_tf.transform.rotation.z = quat.z();
        asparagus_tf.transform.rotation.w = quat.w();
        
        // 4. TFブロードキャスト
        tf_broadcaster_.sendTransform(asparagus_tf);
        
        // 5. rtabmapに保存
        return saveToRtabmap(asparagus_id, asparagus_tf, measurement);
    }
    
private:
    // rtabmapにアスパラガス情報を保存
    bool saveToRtabmap(int asparagus_id, 
                       const geometry_msgs::msg::TransformStamped& tf,
                       const AsparagusMeasurement& measurement) {
        
        auto request = std::make_shared<rtabmap_ros::srv::AddLabel::Request>();
        
        // ラベル情報作成
        std::stringstream label_text;
        label_text << "asparagus_" << asparagus_id 
                   << "_L" << std::fixed << std::setprecision(1) << measurement.length * 100 << "cm"
                   << "_G" << measurement.grade
                   << "_C" << std::fixed << std::setprecision(1) << measurement.curvature * 100 << "cm"
                   << "_D" << std::fixed << std::setprecision(1) << measurement.diameter * 1000 << "mm";
        
        request->label = label_text.str();
        request->stamp = tf.header.stamp;
        
        // 座標設定
        request->pose.position.x = tf.transform.translation.x;
        request->pose.position.y = tf.transform.translation.y;
        request->pose.position.z = tf.transform.translation.z;
        request->pose.orientation = tf.transform.rotation;
        
        // 非同期サービスコール
        auto future = rtabmap_add_label_client_->async_send_request(request);
        
        return future.wait_for(std::chrono::seconds(1)) == std::future_status::ready && 
               future.get()->success;
    }
    
    // 根元位置計算（最下位点群の重心）
    Eigen::Vector3f calculateStemBasePosition(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud) {
        // Z座標最小値付近の点群を抽出
        float min_z = std::numeric_limits<float>::max();
        for (const auto& point : cloud->points) {
            min_z = std::min(min_z, point.z);
        }
        
        pcl::PointCloud<pcl::PointXYZRGB>::Ptr base_points(new pcl::PointCloud<pcl::PointXYZRGB>);
        float base_threshold = min_z + 0.02f;  // 2cm範囲
        
        for (const auto& point : cloud->points) {
            if (point.z <= base_threshold) {
                base_points->points.push_back(point);
            }
        }
        
        // 重心計算
        Eigen::Vector4f centroid;
        pcl::compute3DCentroid(*base_points, centroid);
        return Eigen::Vector3f(centroid[0], centroid[1], centroid[2]);
    }
    
    // アスパラガス形状オブジェクトの作成・公開
    void publishAsparagusMeshMarker(int asparagus_id, 
                                   const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& asparagus_cloud,
                                   const AsparagusMeasurement& measurement) {
        
        // 1. Markerメッセージ作成
        visualization_msgs::msg::Marker marker;
        marker.header.frame_id = "map";
        marker.header.stamp = node_->now();
        marker.ns = "asparagus_mesh";
        marker.id = asparagus_id;
        marker.type = visualization_msgs::msg::Marker::TRIANGLE_LIST;
        marker.action = visualization_msgs::msg::Marker::ADD;
        
        // 2. 点群からメッシュ生成
        createAsparagusMesh(asparagus_cloud, marker);
        
        // 3. グレード別色設定
        setMarkerColorByGrade(marker, measurement.grade);
        
        // 4. マーカー公開
        mesh_marker_pub_->publish(marker);
        
        // 5. 点群オブジェクトも公開（詳細表示用）
        publishAsparagusCylinder(asparagus_id, asparagus_cloud, measurement);
    }
    
private:
    rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr mesh_marker_pub_;
    rclcpp::Publisher<visualization_msgs::msg::MarkerArray>::SharedPtr cylinder_marker_pub_;
    
    // アスパラガス形状のメッシュ生成
    void createAsparagusMesh(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud,
                           visualization_msgs::msg::Marker& marker) {
        
        // PCA分析で軸方向取得
        Eigen::Matrix3f eigenvectors;
        Eigen::Vector3f eigenvalues;
        computePCA(cloud, eigenvectors, eigenvalues);
        
        // アスパラガスを円柱近似でメッシュ化
        std::vector<geometry_msgs::msg::Point> vertices;
        std::vector<std_msgs::msg::ColorRGBA> colors;
        
        // セグメント化して円柱作成
        int segments = 20;  // 長さ方向セグメント数
        int radial_points = 8;  // 円周方向点数
        
        for (int i = 0; i < segments; ++i) {
            float z_ratio = static_cast<float>(i) / (segments - 1);
            float radius = calculateRadiusAtPosition(cloud, z_ratio);
            
            // 各セグメントで円柱面作成
            createCylinderSegment(vertices, colors, cloud, z_ratio, radius, radial_points);
        }
        
        // マーカーに設定
        marker.points = vertices;
        marker.colors = colors;
        marker.scale.x = marker.scale.y = marker.scale.z = 1.0;
    }
    
    // グレード別色設定
    void setMarkerColorByGrade(visualization_msgs::msg::Marker& marker, const std::string& grade) {
        std_msgs::msg::ColorRGBA color;
        color.a = 0.8;  // 80%不透明
        
        if (grade == "A級") {
            color.r = 0.0; color.g = 1.0; color.b = 0.0;  // 緑
        } else if (grade == "B級") {
            color.r = 1.0; color.g = 1.0; color.b = 0.0;  // 黄
        } else if (grade == "C級") {
            color.r = 1.0; color.g = 0.5; color.b = 0.0;  // オレンジ
        } else {
            color.r = 0.5; color.g = 0.5; color.b = 0.5;  // グレー
        }
        
        marker.color = color;
    }
    
    // 詳細表示用円柱マーカー
    void publishAsparagusCylinder(int asparagus_id, 
                                 const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud,
                                 const AsparagusMeasurement& measurement) {
        
        visualization_msgs::msg::MarkerArray marker_array;
        
        // 本体円柱
        visualization_msgs::msg::Marker cylinder;
        cylinder.header.frame_id = "map";
        cylinder.header.stamp = node_->now();
        cylinder.ns = "asparagus_cylinder";
        cylinder.id = asparagus_id * 10;  // IDを分離
        cylinder.type = visualization_msgs::msg::Marker::CYLINDER;
        cylinder.action = visualization_msgs::msg::Marker::ADD;
        
        // 位置・姿勢設定
        Eigen::Vector3f center = calculateStemCenter(cloud);
        cylinder.pose.position.x = center.x();
        cylinder.pose.position.y = center.y();
        cylinder.pose.position.z = center.z();
        
        // サイズ設定
        cylinder.scale.x = cylinder.scale.y = measurement.diameter;  // 直径
        cylinder.scale.z = measurement.length;  // 長さ
        
        // 色設定
        setMarkerColorByGrade(cylinder, measurement.grade);
        
        marker_array.markers.push_back(cylinder);
        
        // 品質情報テキストマーカー
        visualization_msgs::msg::Marker text;
        text.header.frame_id = "map";
        text.header.stamp = node_->now();
        text.ns = "asparagus_info";
        text.id = asparagus_id * 10 + 1;
        text.type = visualization_msgs::msg::Marker::TEXT_VIEW_FACING;
        text.action = visualization_msgs::msg::Marker::ADD;
        
        // テキスト位置（アスパラガス上部）
        text.pose.position.x = center.x();
        text.pose.position.y = center.y();
        text.pose.position.z = center.z() + measurement.length / 2 + 0.05;  // 5cm上
        
        // テキスト内容
        std::stringstream info;
        info << "ID:" << asparagus_id 
             << " L:" << std::fixed << std::setprecision(1) << measurement.length * 100 << "cm"
             << " G:" << measurement.grade
             << " C:" << std::fixed << std::setprecision(1) << measurement.curvature * 100 << "cm";
        text.text = info.str();
        
        text.scale.z = 0.03;  // テキストサイズ（3cm）
        text.color.r = text.color.g = text.color.b = text.color.a = 1.0;  // 白色
        
        marker_array.markers.push_back(text);
        
        // 公開
        cylinder_marker_pub_->publish(marker_array);
    }
};
```

#### 7. **アスパラガス骨格ポイント抽出・表示**
- **骨格ポイント抽出**: 頂点から根元まで等間隔で5-10点のポイント配列を生成
- **ピンク色表示**: ライン接続と◯マーカーで画像にオーバーレイ表示
- **設定可能ポイント数**: 5点・10点を設定ファイルで切り替え可能
- **3D座標保存**: 各ポイントの3D座標をメッセージとして公開
- **品質分析連携**: 骨格ポイントを使用した詳細な曲がり度・長さ測定

```cpp
// アスパラガス骨格ポイント管理クラス
class AsparagusSkeleton {
public:
    struct SkeletonPoint {
        cv::Point2f image_point;     // 2D画像座標
        cv::Point3f world_point;     // 3D世界座標  
        float distance_from_base;    // 根元からの距離
        float radius_at_point;       // その点での半径
    };
    
    struct AsparagusSkeleton {
        int asparagus_id;
        std::vector<SkeletonPoint> skeleton_points;
        float total_length;
        float max_curvature;
        std::string extraction_method;  // "pca", "medial_axis", "centerline"
        rclcpp::Time timestamp;
    };

private:
    int skeleton_points_count_;      // 骨格ポイント数（5または10）
    cv::Scalar skeleton_color_;      // ピンク色 (255, 0, 255)
    int skeleton_line_thickness_;    // ライン太さ
    int skeleton_point_radius_;      // ◯マーカー半径
    
public:
    // 点群から骨格ポイントを抽出
    AsparagusSkeleton extractSkeletonFromPointCloud(
        int asparagus_id,
        const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& asparagus_cloud,
        const cv::Mat& camera_matrix) {
        
        AsparagusSkeleton skeleton;
        skeleton.asparagus_id = asparagus_id;
        skeleton.timestamp = rclcpp::Clock().now();
        skeleton.extraction_method = "pca_centerline";
        
        // 1. PCA分析で主軸方向を取得
        Eigen::Matrix3f eigenvectors;
        Eigen::Vector3f eigenvalues;
        computePCA(asparagus_cloud, eigenvectors, eigenvalues);
        
        // 2. 主軸に沿って点群をソート
        std::vector<pcl::PointXYZRGB> sorted_points = sortPointsAlongMainAxis(
            asparagus_cloud, eigenvectors.col(0));
        
        // 3. 等間隔でポイントを抽出
        skeleton.skeleton_points = extractEquidistantPoints(
            sorted_points, skeleton_points_count_, camera_matrix);
        
        // 4. 長さと曲率を計算
        skeleton.total_length = calculateSkeletonLength(skeleton.skeleton_points);
        skeleton.max_curvature = calculateMaxCurvature(skeleton.skeleton_points);
        
        return skeleton;
    }
    
    // 画像にピンク色で骨格を描画
    void drawSkeletonOnImage(cv::Mat& image, const AsparagusSkeleton& skeleton) {
        if (skeleton.skeleton_points.size() < 2) return;
        
        // ライン描画
        for (size_t i = 1; i < skeleton.skeleton_points.size(); ++i) {
            cv::line(image, 
                    skeleton.skeleton_points[i-1].image_point,
                    skeleton.skeleton_points[i].image_point,
                    skeleton_color_,      // ピンク色 (255, 0, 255)
                    skeleton_line_thickness_);
        }
        
        // ポイントマーカー（◯）描画
        for (const auto& point : skeleton.skeleton_points) {
            cv::circle(image,
                      point.image_point,
                      skeleton_point_radius_,
                      skeleton_color_,      // ピンク色
                      -1);  // 塗りつぶし
            
            // 外枠（白色）でポイントを目立たせる
            cv::circle(image,
                      point.image_point,
                      skeleton_point_radius_ + 1,
                      cv::Scalar(255, 255, 255),  // 白色
                      1);   // 1ピクセル枠
        }
    }
    
private:
    // 等間隔ポイント抽出
    std::vector<SkeletonPoint> extractEquidistantPoints(
        const std::vector<pcl::PointXYZRGB>& sorted_points,
        int target_count,
        const cv::Mat& camera_matrix) {
        
        std::vector<SkeletonPoint> skeleton_points;
        if (sorted_points.size() < 2) return skeleton_points;
        
        // 累積距離を計算
        std::vector<float> cumulative_distances;
        cumulative_distances.push_back(0.0f);
        
        for (size_t i = 1; i < sorted_points.size(); ++i) {
            float dist = cv::norm(cv::Point3f(sorted_points[i].x, sorted_points[i].y, sorted_points[i].z) -
                                cv::Point3f(sorted_points[i-1].x, sorted_points[i-1].y, sorted_points[i-1].z));
            cumulative_distances.push_back(cumulative_distances.back() + dist);
        }
        
        float total_length = cumulative_distances.back();
        
        // 等間隔でポイントを抽出
        for (int i = 0; i < target_count; ++i) {
            float target_distance = (total_length * i) / (target_count - 1);
            
            // 線形補間で正確な位置を計算
            SkeletonPoint skel_point = interpolatePointAtDistance(
                sorted_points, cumulative_distances, target_distance, camera_matrix);
            
            skel_point.distance_from_base = target_distance;
            skeleton_points.push_back(skel_point);
        }
        
        return skeleton_points;
    }
    
    // 最大曲率計算（3点を使った曲率計算）
    float calculateMaxCurvature(const std::vector<SkeletonPoint>& points) {
        if (points.size() < 3) return 0.0f;
        
        float max_curvature = 0.0f;
        
        for (size_t i = 1; i < points.size() - 1; ++i) {
            // 3点を使った曲率計算
            cv::Point3f p1 = points[i-1].world_point;
            cv::Point3f p2 = points[i].world_point;
            cv::Point3f p3 = points[i+1].world_point;
            
            // ベクトル計算
            cv::Point3f v1 = p2 - p1;
            cv::Point3f v2 = p3 - p2;
            
            // 外積による曲率計算
            cv::Point3f cross_product = v1.cross(v2);
            float curvature = cv::norm(cross_product) / 
                            (cv::norm(v1) * cv::norm(v2) * cv::norm(p3 - p1));
            
            max_curvature = std::max(max_curvature, curvature);
        }
        
        return max_curvature;
    }
};
```

### 骨格ポイント情報メッセージ定義

```cpp
// カスタムメッセージ定義（msg/AsparagusSkeleton.msg）
/*
# アスパラガス骨格情報メッセージ
std_msgs/Header header
int32 asparagus_id
string extraction_method
float32 total_length
float32 max_curvature
geometry_msgs/Point[] skeleton_points_3d    # 3D骨格ポイント配列
geometry_msgs/Point[] skeleton_points_2d    # 2D画像座標配列  
float32[] distances_from_base               # 各ポイントの根元からの距離
float32[] radius_at_points                  # 各ポイントでの半径
string grade                                # グレード情報
float32 confidence                          # 骨格抽出信頼度
*/

// 公開用パブリッシャーの追加
class FvAsparaAnalyzerNode : public rclcpp::Node {
private:
    // 骨格情報公開用パブリッシャー
    rclcpp::Publisher<fv_aspara_analyzer::msg::AsparagusSkeleton>::SharedPtr skeleton_pub_;
    rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr skeleton_marker_pub_;
    
    AsparagusSkeleton skeleton_extractor_;
    
public:
    FvAsparaAnalyzerNode() : Node("fv_aspara_analyzer_node") {
        // 骨格情報パブリッシャー初期化
        std::string skeleton_topic = this->get_parameter("skeleton_topic").as_string();
        skeleton_pub_ = this->create_publisher<fv_aspara_analyzer::msg::AsparagusSkeleton>(
            skeleton_topic, 10);
        skeleton_marker_pub_ = this->create_publisher<visualization_msgs::msg::Marker>(
            "/asparagus/skeleton_markers", 10);
    }
    
private:
    // 骨格情報を公開
    void publishSkeletonInfo(const AsparagusSkeleton::AsparagusSkeleton& skeleton,
                           const AsparagusMeasurement& measurement) {
        
        // 1. カスタムメッセージ作成
        auto skeleton_msg = std::make_unique<fv_aspara_analyzer::msg::AsparagusSkeleton>();
        skeleton_msg->header.stamp = this->now();
        skeleton_msg->header.frame_id = "map";
        skeleton_msg->asparagus_id = skeleton.asparagus_id;
        skeleton_msg->extraction_method = skeleton.extraction_method;
        skeleton_msg->total_length = skeleton.total_length;
        skeleton_msg->max_curvature = skeleton.max_curvature;
        skeleton_msg->grade = measurement.grade;
        skeleton_msg->confidence = measurement.confidence;
        
        // 骨格ポイント配列設定
        for (const auto& point : skeleton.skeleton_points) {
            geometry_msgs::msg::Point point_3d;
            point_3d.x = point.world_point.x;
            point_3d.y = point.world_point.y;
            point_3d.z = point.world_point.z;
            skeleton_msg->skeleton_points_3d.push_back(point_3d);
            
            geometry_msgs::msg::Point point_2d;
            point_2d.x = point.image_point.x;
            point_2d.y = point.image_point.y;
            point_2d.z = 0.0;
            skeleton_msg->skeleton_points_2d.push_back(point_2d);
            
            skeleton_msg->distances_from_base.push_back(point.distance_from_base);
            skeleton_msg->radius_at_points.push_back(point.radius_at_point);
        }
        
        skeleton_pub_->publish(std::move(skeleton_msg));
        
        // 2. 3D骨格ラインマーカー作成・公開
        publishSkeleton3DMarker(skeleton);
    }
    
    // 3D空間での骨格ラインマーカー公開
    void publishSkeleton3DMarker(const AsparagusSkeleton::AsparagusSkeleton& skeleton) {
        visualization_msgs::msg::Marker marker;
        marker.header.frame_id = "map";
        marker.header.stamp = this->now();
        marker.ns = "asparagus_skeleton";
        marker.id = skeleton.asparagus_id;
        marker.type = visualization_msgs::msg::Marker::LINE_STRIP;
        marker.action = visualization_msgs::msg::Marker::ADD;
        
        // 骨格ライン設定
        marker.scale.x = 0.005;  // 5mmライン幅
        marker.color.r = 1.0;    // ピンク色
        marker.color.g = 0.0;
        marker.color.b = 1.0;
        marker.color.a = 0.8;    // 80%不透明
        
        // 3Dポイント追加
        for (const auto& point : skeleton.skeleton_points) {
            geometry_msgs::msg::Point p;
            p.x = point.world_point.x;
            p.y = point.world_point.y;
            p.z = point.world_point.z;
            marker.points.push_back(p);
        }
        
        skeleton_marker_pub_->publish(marker);
    }
};
```

### 選択中アスパラガス情報メッセージ定義

```cpp
// カスタムメッセージ定義（msg/SelectedAsparagusCutInfo.msg）
/*
# 選択中アスパラガス切断情報メッセージ
std_msgs/Header header
int32 asparagus_id
bool is_selected                            # 選択状態
float32 length                              # 長さ（メートル）
float32 distance_from_camera                # カメラからの距離（メートル）
float32 curvature                           # 曲がり度（メートル）
float32 diameter                            # 太さ（メートル）
string grade                                # グレード（A級、B級、C級、規格外）
bool is_cutting_target                      # 切断対象かどうか
geometry_msgs/Point2D cut_point_pixel       # 根元の画像座標（ピクセル）
geometry_msgs/Point cut_point_world         # 根元の3D世界座標（メートル）
float32 confidence                          # 品質分析信頼度
*/

// カスタムメッセージ定義（msg/Point2D.msg）
/*
# 2D画像座標用メッセージ
float32 x    # X座標（ピクセル）
float32 y    # Y座標（ピクセル）
*/

// 選択中アスパラガス情報管理クラス
class SelectedAsparagusCutInfo {
private:
    rclcpp::Publisher<fv_aspara_analyzer::msg::SelectedAsparagusCutInfo>::SharedPtr selected_asparagus_pub_;
    int current_selected_id_;
    
public:
    SelectedAsparagusCutInfo(rclcpp::Node::SharedPtr node) : current_selected_id_(-1) {
        selected_asparagus_pub_ = node->create_publisher<fv_aspara_analyzer::msg::SelectedAsparagusCutInfo>(
            "/selected_asparagus_info", 10);
    }
    
    // 選択中アスパラガス情報を公開
    void publishSelectedAsparagusCutInfo(
        int asparagus_id,
        const AsparagusMeasurement& measurement,
        const AsparagusSkeleton::AsparagusSkeleton& skeleton,
        const cv::Mat& camera_matrix,
        const cv::Mat& depth_image) {
        
        auto cut_info_msg = std::make_unique<fv_aspara_analyzer::msg::SelectedAsparagusCutInfo>();
        cut_info_msg->header.stamp = rclcpp::Clock().now();
        cut_info_msg->header.frame_id = "map";
        
        // 基本情報
        cut_info_msg->asparagus_id = asparagus_id;
        cut_info_msg->is_selected = (asparagus_id != -1);
        
        if (asparagus_id == -1) {
            // 選択なしの場合
            selected_asparagus_pub_->publish(std::move(cut_info_msg));
            return;
        }
        
        // 品質情報
        cut_info_msg->length = measurement.length;
        cut_info_msg->curvature = measurement.curvature;
        cut_info_msg->diameter = measurement.diameter;
        cut_info_msg->grade = measurement.grade;
        cut_info_msg->confidence = measurement.confidence;
        cut_info_msg->is_cutting_target = (measurement.length >= 0.23);  // 23cm以上
        
        // 根元ポイント（骨格ポイントの最初=根元）
        if (!skeleton.skeleton_points.empty()) {
            const auto& base_point = skeleton.skeleton_points[0];  // 根元ポイント
            
            // 2D画像座標
            cut_info_msg->cut_point_pixel.x = base_point.image_point.x;
            cut_info_msg->cut_point_pixel.y = base_point.image_point.y;
            
            // 3D世界座標
            cut_info_msg->cut_point_world.x = base_point.world_point.x;
            cut_info_msg->cut_point_world.y = base_point.world_point.y;
            cut_info_msg->cut_point_world.z = base_point.world_point.z;
            
            // カメラからの距離計算（根元まで）
            cut_info_msg->distance_from_camera = calculateDistanceFromCamera(
                base_point.world_point, camera_matrix);
        }
        
        selected_asparagus_pub_->publish(std::move(cut_info_msg));
        current_selected_id_ = asparagus_id;
    }
    
private:
    // カメラからの距離計算
    float calculateDistanceFromCamera(const cv::Point3f& world_point, 
                                    const cv::Mat& camera_matrix) {
        // カメラ座標系の原点からの距離
        return std::sqrt(world_point.x * world_point.x + 
                        world_point.y * world_point.y + 
                        world_point.z * world_point.z);
    }
};

// メインノードクラスに統合
class FvAsparaAnalyzerNode : public rclcpp::Node {
private:
    SelectedAsparagusCutInfo selected_asparagus_manager_;
    
public:
    FvAsparaAnalyzerNode() : Node("fv_aspara_analyzer_node"),
                           selected_asparagus_manager_(shared_from_this()) {
        // 既存の初期化処理...
    }
    
    // 選択中アスパラガス変更時の処理
    void onSelectedAsparaguChanged(int new_selected_id) {
        if (new_selected_id != -1 && detected_asparagus_.count(new_selected_id)) {
            const auto& measurement = asparagus_measurements_[new_selected_id];
            const auto& skeleton = asparagus_skeletons_[new_selected_id];
            
            // 選択中アスパラガス情報を公開
            selected_asparagus_manager_.publishSelectedAsparagusCutInfo(
                new_selected_id, measurement, skeleton, camera_matrix_, latest_depth_image_);
        } else {
            // 選択解除の場合
            selected_asparagus_manager_.publishSelectedAsparagusCutInfo(
                -1, AsparagusMeasurement{}, AsparagusSkeleton::AsparagusSkeleton{}, 
                camera_matrix_, latest_depth_image_);
        }
    }
};
```

#### 8. **3Dマップ可視化機能**
- **メッシュマーカー**: 高品質アスパラガス形状をTRIANGLE_LISTで表示
- **円柱マーカー**: 簡略化されたアスパラガス形状をCYLINDERで表示  
- **骨格ラインマーカー**: 骨格ポイントを3D空間でライン表示
- **テキスト情報**: 品質情報（ID・長さ・グレード・曲がり度）を3D空間に表示
- **グレード別色分け**: A級=緑、B級=黄、C級=オレンジ、規格外=グレー
- **永続表示**: rtabmapと連携してマップ保存時に形状も保存

```cpp
// マーカー公開用の設定追加
class FvAsparaAnalyzerNode : public rclcpp::Node {
private:
    // マーカー公開用パブリッシャー
    rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr asparagus_mesh_pub_;
    rclcpp::Publisher<visualization_msgs::msg::MarkerArray>::SharedPtr asparagus_markers_pub_;
    
public:
    FvAsparaAnalyzerNode() : Node("fv_aspara_analyzer_node") {
        // マーカーパブリッシャー初期化
        asparagus_mesh_pub_ = this->create_publisher<visualization_msgs::msg::Marker>(
            "/asparagus/mesh_markers", 10);
        asparagus_markers_pub_ = this->create_publisher<visualization_msgs::msg::MarkerArray>(
            "/asparagus/markers", 10);
    }
};
```

#### 6. **パフォーマンス最適化**
- 点群描画は選択中アスパラガスのみ
- フレームレート維持のため適度な更新頻度制御
- メモリ効率的な点群処理
- 合成処理の並列化とキャッシュ最適化

## 今後の課題

1. **リアルタイム性能の最適化**
2. **複数アスパラガス同時処理**
3. **異常検知・品質評価の高精度化**
4. **他のセンサー（IMU等）との統合**

---

このドキュメントに基づいて、統合されたアスパラガス分析ノードを実装する。